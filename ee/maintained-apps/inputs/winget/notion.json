{
  "name": "Notion",
  "slug": "notion/windows",
  "install_script": "$installArgs = \"/S\"\n$exeFilePath = \"${env:INSTALLER_PATH}\"\n$exitCode = 0\n\ntry {\n\n# Copy the installer to a public folder so that all can access it\n# users\n$exeFilename = Split-Path $exeFilePath -leaf\nCopy-Item -Path $exeFilePath -Destination \"${env:PUBLIC}\" -Force\n$exeFilePath = \"${env:PUBLIC}\\$exeFilename\"\n\n# Wait for the user to be logged in\nwhile ($true) {\n    $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n\n    if ($user -and $user -like \"*\\\\*\") {\n        Write-Output \"Interactive user detected: $user\"\n        break\n    } else {\n        Start-Sleep -Seconds 5\n    }\n}\n\n# Task properties. The task will be started by the logged in user\n$action = New-ScheduledTaskAction -Execute \"$exeFilePath\" `\n    -Argument \"$installArgs\"\n$trigger = New-ScheduledTaskTrigger -AtLogOn\n$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n# Create a task object with the properties defined above\n$task = New-ScheduledTask -Action $action -Trigger $trigger `\n    -Settings $settings\n\n# Register the task\n$taskName = \"fleet-install-$exeFilename\"\nRegister-ScheduledTask \"$taskName\" -InputObject $task -User \"$userName\"\n\n# keep track of the start time to cancel if taking too long to start\n$startDate = Get-Date\n\n# Start the task now that it is ready\nStart-ScheduledTask -TaskName \"$taskName\" -TaskPath \"\\\"\n\n# Wait for the task to be running\n$state = (Get-ScheduledTask -TaskName \"$taskName\").State\nWrite-Host \"ScheduledTask is '$state'\"\n\nwhile ($state  -ne \"Running\") {\n    Write-Host \"ScheduledTask is '$state'. Waiting to run .exe...\"\n\n    $endDate = Get-Date\n    $elapsedTime = New-Timespan -Start $startDate -End $endDate\n    if ($elapsedTime.TotalSeconds -gt 120) {\n        Throw \"Timed-out waiting for scheduled task state.\"\n    }\n\n    Start-Sleep -Seconds 1\n    $state = (Get-ScheduledTask -TaskName \"$taskName\").State\n}\n\n# Wait for the task to be done\n$state = (Get-ScheduledTask -TaskName \"$taskName\").State\nwhile ($state  -eq \"Running\") {\n    Write-Host \"ScheduledTask is '$state'. Waiting for .exe to complete...\"\n\n    $endDate = Get-Date\n    $elapsedTime = New-Timespan -Start $startDate -End $endDate\n    if ($elapsedTime.TotalSeconds -gt 120) {\n        Throw \"Timed-out waiting for scheduled task state.\"\n    }\n\n    Start-Sleep -Seconds 10\n    $state = (Get-ScheduledTask -TaskName \"$taskName\").State\n}\n\n# Remove task\nWrite-Host \"Removing ScheduledTask: $taskName.\"\nUnregister-ScheduledTask -TaskName \"$taskName\" -Confirm:$false\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Remove installer\n    Remove-Item -Path $exeFilePath -Force\n}\n\nExit $exitCode",
  "uninstall_script": "$softwareName = \"Notion\"\n$productKey = \"661f0cc6-343a-59cb-a5e8-8f6324cc6998\"\n$taskName = \"fleet-uninstall-$softwareName\"\n$uninstallScriptPath = \"$env:PUBLIC\\uninstall-$softwareName.ps1\"\n$logFile = \"$env:PUBLIC\\uninstall-output-$softwareName.txt\"\n$exitCodeFile = \"$env:PUBLIC\\uninstall-exitcode-$softwareName.txt\"\n\n# Embedded uninstall script\n$userScript = @\"\n`$uninstallArgs = \"/S\"\n`$userKey = \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$productKey\"\n`$exitCode = 0\n`$logFile = \"$logFile\"\n`$exitCodeFile = \"$exitCodeFile\"\n\ntry {\n    `$key = Get-ItemProperty -Path `$userKey -ErrorAction Stop\n\n    `$uninstallCommand = if (`$key.QuietUninstallString) {\n        `$key.QuietUninstallString\n    } else {\n        `$key.UninstallString\n    }\n\n    `$splitArgs = `$uninstallCommand.Split('\"')\n    if (`$splitArgs.Length -gt 1) {\n        if (`$splitArgs.Length -eq 3) {\n            `$uninstallArgs = \"`$splitArgs[2] `$uninstallArgs\".Trim()\n        } elseif (`$splitArgs.Length -gt 3) {\n            Throw \"Uninstall command contains multiple quoted strings. Please update the uninstall script.`nUninstall command: `$uninstallCommand\"\n        }\n        `$uninstallCommand = `$splitArgs[1]\n    }\n\n    Write-Host \"Uninstall command: `$uninstallCommand\"\n    Write-Host \"Uninstall args: `$uninstallArgs\"\n\n    `$processOptions = @{\n        FilePath = `$uninstallCommand\n        PassThru = `$true\n        Wait     = `$true\n    }\n\n    if (`$uninstallArgs -ne '') {\n        `$processOptions.ArgumentList = \"`$uninstallArgs\"\n    }\n\n    `$process = Start-Process @processOptions\n    `$exitCode = `$process.ExitCode\n    Write-Host \"Uninstall exit code: `$exitCode\"\n}\ncatch {\n    Write-Host \"Error: `$_.Exception.Message\"\n    `$exitCode = 1\n}\nfinally {\n    Set-Content -Path `$exitCodeFile -Value `$exitCode\n}\nExit `$exitCode\n\"@\n\n$exitCode = 0\n\ntry {\n    # Write the uninstall script to disk\n    Set-Content -Path $uninstallScriptPath -Value $userScript -Force\n\n    # Build task action: run script, redirect stdout/stderr to log file\n    $action = New-ScheduledTaskAction -Execute \"powershell.exe\" `\n        -Argument \"-WindowStyle Hidden -ExecutionPolicy Bypass -File `\\\"$uninstallScriptPath`\\\" *> `\\\"$logFile`\\\" 2>&1\"\n\n    $trigger = New-ScheduledTaskTrigger -AtLogOn\n\n    $userName = (Get-CimInstance Win32_ComputerSystem).UserName\n    if (-not $userName) { $userName = \"$env:USERNAME\" }\n\n    $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries\n\n    $principal = New-ScheduledTaskPrincipal -UserId $userName -RunLevel Highest\n\n    $task = New-ScheduledTask -Action $action -Trigger $trigger -Settings $settings -Principal $principal\n\n    Register-ScheduledTask -TaskName $taskName -InputObject $task -User $userName -Force\n\n    # Start the task\n    Start-ScheduledTask -TaskName $taskName\n\n    # Wait for it to start\n    $startDate = Get-Date\n    $state = (Get-ScheduledTask -TaskName $taskName).State\n    while ($state -ne \"Running\") {\n        Start-Sleep -Seconds 1\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to start.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Wait for it to complete\n    while ($state -eq \"Running\") {\n        Start-Sleep -Seconds 5\n        $elapsed = (New-Timespan -Start $startDate).TotalSeconds\n        if ($elapsed -gt 120) { throw \"Timeout waiting for task to finish.\" }\n        $state = (Get-ScheduledTask -TaskName $taskName).State\n    }\n\n    # Show task output\n    if (Test-Path $logFile) {\n        Write-Host \"`n--- Scheduled Task Output ---\"\n        Get-Content $logFile | Write-Host\n    }\n\n    if (Test-Path $exitCodeFile) {\n        $exitCode = Get-Content $exitCodeFile\n        Write-Host \"`nScheduled task exit code: $exitCode\"\n    }\n\n} catch {\n    Write-Host \"Error: $_\"\n    $exitCode = 1\n} finally {\n    # Clean up\n    Write-Host \"Cleaning up...\"\n    Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction SilentlyContinue\n    Remove-Item -Path $uninstallScriptPath -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue\n    Remove-Item -Path $exitCodeFile -Force -ErrorAction SilentlyContinue\n}\n\nExit $exitCode"
}