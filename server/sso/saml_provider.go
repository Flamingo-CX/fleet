// Package sso wraps SSO functionality to be used by Fleet's service layer.
// It uses https://github.com/crewjam/saml SAML parsing and validation.
//
// Fleet uses "RelayState" defined by the SAML protocol to track sessions.
//
// Initiate SSO:
//   - Fleet generates a random RelayState token, and SAML AuthnRequest with a random Request ID.
//   - Fleet will store the session in Redis, RelayState token as the key, and Request ID + Original URL + configured Metadata as value.
//   - Fleet returns a URL that redirects the user to the IdP with AuthnRequest and RelayState as query arguments in the URL.
//
// Callback SSO:
//   - Fleet receives RelayState and SAMLResponse in the request.
//   - Fleet uses RelayState to load the session from Redis.
//   - Fleet uses the Request ID + Metadata loaded from Redis to verify the SAMLResponse.
//   - If verification succeeds, Fleet redirects the user to the Original URL loaded from Redis.
//
// IdP-initiated Callback SSO (if enabled by the admin):
//   - Fleet receives SAMLResponse without RelayState or RequestID.
//   - Fleet uses the configured metadata to verify the SAMLResponse.
package sso

import (
	"context"
	"net/url"

	"github.com/crewjam/saml"
	"github.com/fleetdm/fleet/v4/server/contexts/ctxerr"
	"github.com/fleetdm/fleet/v4/server/fleet"
)

// SAMLProviderFromConfiguredMetadata creates a SAML provider that can validate SAML responses
// from the configured SSO metadata.
func SAMLProviderFromConfiguredMetadata(
	ctx context.Context,
	entityID string,
	acsURL string,
	settings *fleet.SSOProviderSettings,
) (*saml.ServiceProvider, error) {
	entityDescriptor, err := GetMetadata(settings)
	if err != nil {
		return nil, ctxerr.Wrap(ctx, &fleet.BadRequestError{
			Message:     "failed to get and parse IdP metadata",
			InternalErr: err,
		})
	}
	parsedACSURL, err := url.Parse(acsURL)
	if err != nil {
		return nil, ctxerr.Wrap(ctx, err, "failed to parse ACS URL")
	}
	return &saml.ServiceProvider{
		EntityID:    entityID,
		AcsURL:      *parsedACSURL,
		IDPMetadata: entityDescriptor,
	}, nil
}

// SAMLProviderFromSession creates a SAML provider that can validate SAML responses
// from a valid SSO session (stored in sessionStore).
func SAMLProviderFromSession(
	ctx context.Context,
	relayStateToken string,
	sessionStore SessionStore,
	acsURL *url.URL,
	entityID string,
	expectedAudiences []string,
) (samlProvider *saml.ServiceProvider, requestID string, err error) {
	session, err := sessionStore.Fullfill(relayStateToken)
	if err != nil {
		return nil, "", ctxerr.Wrap(ctx, err, "validate request in session")
	}
	entityDescriptor, err := ParseMetadata([]byte(session.Metadata))
	if err != nil {
		return nil, "", ctxerr.Wrap(ctx, err, "failed to parse metadata")
	}

	return &saml.ServiceProvider{
		EntityID:    entityID,
		AcsURL:      *acsURL,
		IDPMetadata: entityDescriptor,
		ValidateAudienceRestriction: func(assertion *saml.Assertion) error {
			return validateAudiences(assertion, expectedAudiences)
		},
	}, session.RequestID, nil
}

// SAMLProviderFromSessionOrConfiguredMetadata creates a SAML provider that can validate SAML responses.
// It will create the SAML provider from an existing SSO session (using sessionStore),
// if relayStateToken was generated by Fleet.
// or it will create a SAML provider from the configured metadata if IdP-initiated logins are enabled.
func SAMLProviderFromSessionOrConfiguredMetadata(
	ctx context.Context,
	relayStateToken string,
	sessionStore SessionStore,
	acsURL *url.URL,
	settings *fleet.SSOSettings,
	expectedAudiences []string,
) (samlProvider *saml.ServiceProvider, requestID string, redirectURL string, err error) {
	// We consider a callback as IdP-initiated if the RelayState token does not have the format
	// generated by Fleet in the /api/v1/fleet/sso request (`fleet_` prefix).
	//
	// This check is just to not fail IdP-initiated logins on scenarios where the IdP sets the `RelayState`
	// in IdP-initiated logins to some resource URL (which we currently don't-use/support).
	idpInitiated := !checkFleetRelayStateToken(relayStateToken)

	var entityDescriptor *saml.EntityDescriptor
	if settings.EnableSSOIdPLogin && idpInitiated {
		// Missing request ID indicates this was IdP-initiated. Only allow if
		// configured to do so.
		var err error
		entityDescriptor, err = GetMetadata(&settings.SSOProviderSettings)
		if err != nil {
			return nil, "", "", ctxerr.Wrap(ctx, err, "failed to parse metadata")
		}
		redirectURL = "/"
	} else {
		session, err := sessionStore.Fullfill(relayStateToken)
		if err != nil {
			return nil, "", "", ctxerr.Wrap(ctx, err, "validate request in session")
		}
		entityDescriptor, err = ParseMetadata([]byte(session.Metadata))
		if err != nil {
			return nil, "", "", ctxerr.Wrap(ctx, err, "failed to parse metadata")
		}
		redirectURL = session.OriginalURL
		requestID = session.RequestID
	}

	return &saml.ServiceProvider{
		EntityID:           settings.EntityID,
		AcsURL:             *acsURL,
		DefaultRedirectURI: redirectURL,
		IDPMetadata:        entityDescriptor,
		ValidateAudienceRestriction: func(assertion *saml.Assertion) error {
			return validateAudiences(assertion, expectedAudiences)
		},
		AllowIDPInitiated: settings.EnableSSOIdPLogin,
	}, requestID, redirectURL, nil
}
